// Model Loader - Automatick√© naƒç√≠t√°n√≠ a registrace model≈Ø
// Verze: 2.1 - S podporou v≈°ech provider≈Ø

class ModelLoader {
    constructor() {
        this.loadedModels = new Map();
        this.initialized = false;
        this.failedModels = new Map(); // Pro tracking selh√°n√≠
    }

    // Hlavn√≠ inicializaƒçn√≠ funkce
    async initialize() {
        if (this.initialized) return;
        
        console.log('üîÑ Model Loader initializing...');
        
        try {
            // 1. Naƒç√≠st v≈°echny modely z registry - MUS√ç b√Ωt prvn√≠
            await this.loadModelsFromRegistry();
            
            // 2. Naƒç√≠st u≈æivatelsk√© preference - a≈æ po naƒçten√≠ model≈Ø
            this.loadUserPreferences();
            
            // 3. Aplikovat debug mode pokud je zapnut√Ω
            if (CONFIG.DEBUG_MODE) {
                this.printDebugInfo();
            }
            
            this.initialized = true;
            console.log('‚úÖ Model Loader ready');
            
        } catch (error) {
            console.error('‚ùå Model Loader initialization failed:', error);
            // Cleanup p≈ôi selh√°n√≠
            this.loadedModels.clear();
            this.failedModels.clear();
            this.initialized = false;
            throw error;
        }
    }

    // Naƒç√≠st modely z registry
    async loadModelsFromRegistry() {
        console.log('üì¶ Loading models from registry...');
        
        // Ovƒõ≈ôit dostupnost z√°vislost√≠
        if (!window.ModelsRegistryHelper) {
            throw new Error('ModelsRegistryHelper not available');
        }
        
        if (!window.modelManager) {
            throw new Error('Model Manager not available - must be initialized first');
        }
        
        const enabledModels = ModelsRegistryHelper.getEnabledModels();
        console.log(`üìã Found ${enabledModels.length} enabled models`);
        
        let successCount = 0;
        let failCount = 0;
        
        for (const modelDef of enabledModels) {
            try {
                // Vytvo≈ô instanci modelu podle providera
                const modelInstance = await this.createModelInstance(modelDef);
                
                if (modelInstance) {
                    // Registruj model v Model Manageru
                    window.modelManager.registerModel(modelDef.id, modelInstance);
                    this.loadedModels.set(modelDef.id, modelDef);
                    successCount++;
                    console.log(`‚úÖ Loaded model: ${modelDef.id}`);
                } else {
                    throw new Error(`Failed to create instance for model: ${modelDef.id}`);
                }
            } catch (error) {
                failCount++;
                this.failedModels.set(modelDef.id, error.message);
                console.error(`‚ùå Failed to load model ${modelDef.id}:`, error);
                
                // Pokraƒçovat s dal≈°√≠mi modely i p≈ôi selh√°n√≠
                continue;
            }
        }
        
        console.log(`üìä Model loading complete: ${successCount} success, ${failCount} failed`);
        
        // Pokud se nepoda≈ôilo naƒç√≠st ≈æ√°dn√Ω model, je to kritick√° chyba
        if (successCount === 0 && enabledModels.length > 0) {
            throw new Error('Failed to load any models');
        }
    }

    // Vytvo≈ôit instanci modelu podle providera
    async createModelInstance(modelDef) {
        if (!modelDef || !modelDef.provider) {
            throw new Error('Invalid model definition');
        }
        
        try {
            switch (modelDef.provider) {
                case 'openai':
                    // Dynamicky naƒç√≠st OpenAI model
                    if (window.OpenAIModel) {
                        return new OpenAIModel(modelDef.id, modelDef);
                    } else {
                        throw new Error('OpenAI model implementation not found');
                    }
                    
                case 'anthropic':
                    // Anthropic (Claude) modely
                    if (window.AnthropicModel) {
                        return new AnthropicModel(modelDef.id, modelDef);
                    } else {
                        console.warn('Anthropic model implementation not found - skipping');
                        return null;
                    }
                    
                case 'perplexity':
                    // Perplexity modely
                    if (window.PerplexityModel) {
                        return new PerplexityModel(modelDef.id, modelDef);
                    } else {
                        console.warn('Perplexity model implementation not found - skipping');
                        return null;
                    }
                    
                case 'together':
                    // Together AI modely
                    if (window.TogetherModel) {
                        return new TogetherModel(modelDef.id, modelDef);
                    } else {
                        console.warn('Together model implementation not found - skipping');
                        return null;
                    }
                    
                case 'cohere':
                    // Cohere modely
                    if (window.CohereModel) {
                        return new CohereModel(modelDef.id, modelDef);
                    } else {
                        console.warn('Cohere model implementation not found - skipping');
                        return null;
                    }
                    
                case 'google':
                    // Google (Gemini) modely - pro budouc√≠ implementaci
                    if (window.GoogleModel) {
                        return new GoogleModel(modelDef.id, modelDef);
                    } else {
                        console.warn('Google model implementation not found - skipping');
                        return null;
                    }
                    
                default:
                    console.warn(`Unknown provider: ${modelDef.provider}`);
                    return null;
            }
        } catch (error) {
            // P≈ôidat kontext k chybƒõ
            error.message = `Error creating ${modelDef.provider} model instance: ${error.message}`;
            throw error;
        }
    }

    // Naƒç√≠st u≈æivatelsk√© preference
    loadUserPreferences() {
        try {
            // Naƒç√≠st viditelnost model≈Ø
            const savedVisibility = localStorage.getItem(
                CONFIG.STORAGE.PREFIX + CONFIG.STORAGE.KEYS.USER_VISIBLE_MODELS
            );
            
            if (savedVisibility) {
                try {
                    const visibleModels = JSON.parse(savedVisibility);
                    
                    if (!Array.isArray(visibleModels)) {
                        throw new Error('Invalid visibility data format');
                    }
                    
                    // Aplikovat viditelnost na modely
                    for (const [modelId, modelDef] of this.loadedModels) {
                        const model = window.modelManager?.models.get(modelId);
                        if (model) {
                            model.visible = visibleModels.includes(modelId);
                        }
                    }
                    
                    console.log('üìã Applied user visibility preferences');
                } catch (error) {
                    console.error('Error loading visibility preferences:', error);
                    // Pokraƒçovat s v√Ωchoz√≠m nastaven√≠m
                }
            } else {
                // Pou≈æ√≠t v√Ωchoz√≠ viditelnost z registry
                console.log('üìã Using default visibility from registry');
            }
        } catch (error) {
            console.error('Error in loadUserPreferences:', error);
            // Nen√≠ kritick√° chyba, pokraƒçovat
        }
    }

    // Debug informace
    printDebugInfo() {
        console.log('üìã Model Registry Debug Info:');
        console.log(`- Total models in registry: ${MODELS_REGISTRY.length}`);
        console.log(`- Enabled models: ${ModelsRegistryHelper.getEnabledModels().length}`);
        console.log(`- Successfully loaded models: ${this.loadedModels.size}`);
        console.log(`- Failed models: ${this.failedModels.size}`);
        
        if (this.failedModels.size > 0) {
            console.log('\n‚ùå Failed models:');
            this.failedModels.forEach((error, modelId) => {
                console.log(`  - ${modelId}: ${error}`);
            });
        }
        
        // Detailn√≠ info o ka≈æd√©m modelu
        if (window.modelManager) {
            const allModels = window.modelManager.getAllModels();
            const visibleModels = window.modelManager.getAvailableModelsSync();
            
            console.log(`\n- Configured models: ${allModels.length}`);
            console.log(`- Visible models: ${visibleModels.length}`);
            
            console.log('\n‚úÖ Ready models:');
            visibleModels.forEach(model => {
                console.log(`  - ${model.name} (${model.id})`);
            });
            
            // Kontrola API kl√≠ƒç≈Ø - pou≈æ√≠vat sync verzi pro debug
            console.log('\nüîë API Keys status:');
            const providers = ModelsRegistryHelper.getProviders();
            providers.forEach(provider => {
                const hasKey = window.modelManager.hasApiKeyCached(provider);
                console.log(`  - ${provider}: ${hasKey ? '‚úÖ configured' : '‚ùå missing'}`);
            });
        }
    }

    // Z√≠skat statistiky o naƒçten√Ωch modelech
    getStats() {
        return {
            totalInRegistry: MODELS_REGISTRY.length,
            enabledInRegistry: ModelsRegistryHelper.getEnabledModels().length,
            loadedModels: this.loadedModels.size,
            failedModels: this.failedModels.size,
            visibleModels: window.modelManager?.getAvailableModelsSync().length || 0
        };
    }

    // Z√≠skat seznam selh√°n√≠
    getFailedModels() {
        return Array.from(this.failedModels.entries()).map(([id, error]) => ({
            id,
            error
        }));
    }

    // Reload model≈Ø (pro p≈ô√≠padnou aktualizaci)
    async reload() {
        console.log('üîÑ Reloading models...');
        
        // Vyƒçistit existuj√≠c√≠ modely
        this.cleanup();
        
        // Znovu naƒç√≠st
        await this.initialize();
    }
    
    // Cleanup metoda
    cleanup() {
        this.loadedModels.clear();
        this.failedModels.clear();
        this.initialized = false;
        console.log('üßπ Model Loader cleaned up');
    }
}

// Vytvo≈ôit glob√°ln√≠ instanci
window.modelLoader = new ModelLoader();

console.log('üì¶ Model Loader ready (v2.1 - All providers)');
